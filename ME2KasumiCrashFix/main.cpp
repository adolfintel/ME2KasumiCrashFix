#include <windows.h>
#include <winuser.h>

#define	patternLength 144
BYTE	pattern[] =	{0x83,0x3D,0xAC,0xA2,0x26,0x01,0x00,0x56,0x74,0x76,0xA1,0xBC,0xA7,0x26,0x01,0x83,0x78,0x54,0x00,0x74,0x6B,0x8B,0x40,0x54,0x83,0x78,0x40,0x00,0x74,0x62,0x8B,0x40,0x3C,0x83,0x38,0x00,0x74,0x5A,0x8B,0x51,0x54,0x8B,0x42,0x3C,0x8B,0x00,0x83,0xB8,0x20,0x03,0x00,0x00,0x00,0x74,0x18,0x8B,0xCA,0x8B,0x51,0x3C,0x8B,0x0A,0xF3,0x0F,0x10,0x81,0x08,0x03,0x00,0x00,0x0F,0x2F,0x81,0x18,0x03,0x00,0x00,0x73,0x2A,0xF6,0x80,0xCC,0x02,0x00,0x00,0x04,0x75,0x21,0xE8,0x23,0xA4,0xE7,0xFF,0x8B,0x35,0xAC,0xA2,0x26,0x01,0x8B,0xD0,0x8B,0xC6,0xE8,0x44,0x8A,0xE6,0xFF,0x85,0xC0,0x74,0x10,0xF6,0x86,0x14,0x04,0x00,0x00,0x04,0x74,0x07,0xB8,0x01,0x00,0x00,0x00,0x5E,0xC3,0x33,0xC0,0x5E,0xC3,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC},
		fixed[] =	{0x83,0x3D,0xAC,0xA2,0x26,0x01,0x00,0x56,0x74,0x76,0xA1,0xBC,0xA7,0x26,0x01,0x85,0xC0,0x74,0x6D,0xEB,0x6F,0x8B,0x40,0x54,0x83,0x78,0x40,0x00,0x74,0x62,0x8B,0x40,0x3C,0x83,0x38,0x00,0x74,0x5A,0x8B,0x51,0x54,0x8B,0x42,0x3C,0x8B,0x00,0x83,0xB8,0x20,0x03,0x00,0x00,0x00,0x74,0x18,0x8B,0xCA,0x8B,0x51,0x3C,0x8B,0x0A,0xF3,0x0F,0x10,0x81,0x08,0x03,0x00,0x00,0x0F,0x2F,0x81,0x18,0x03,0x00,0x00,0x73,0x2A,0xF6,0x80,0xCC,0x02,0x00,0x00,0x04,0x75,0x21,0xE8,0x23,0xA4,0xE7,0xFF,0x8B,0x35,0xAC,0xA2,0x26,0x01,0x8B,0xD0,0x8B,0xC6,0xE8,0x44,0x8A,0xE6,0xFF,0x85,0xC0,0x74,0x10,0xF6,0x86,0x14,0x04,0x00,0x00,0x04,0x74,0x07,0xB8,0x01,0x00,0x00,0x00,0x5E,0xC3,0x33,0xC0,0x5E,0xC3,0x83,0x78,0x54,0x00,0x74,0xF6,0xEB,0x89,0xCC,0xCC,0xCC,0xCC};

bool DataCompare(const BYTE* OpCodes, const BYTE* Mask, const char* StrMask)
{
	while (*StrMask)
	{
		if (*StrMask == 'x' && *OpCodes != *Mask)
			return false;
		++StrMask;
		++OpCodes;
		++Mask;
	}
	return true;
}

DWORD FindPattern(DWORD StartAddress, DWORD CodeLen, BYTE* Mask, char* StrMask, unsigned short ignore)
{
	unsigned short Ign = 0;
	DWORD i = 0;
	while (Ign <= ignore)
	{
		if (DataCompare((BYTE*)(StartAddress + i++), Mask, StrMask))
			++Ign;
		else if (i >= CodeLen)
			return 0;
	}
	return StartAddress + i - 1;
}

DWORD WINAPI Start(LPVOID lpParam)
{
	char patternMask[patternLength + 1];
	for (int i = 0; i < patternLength; i++) patternMask[i] = 'x';
	patternMask[patternLength] = 0;
	DWORD target = FindPattern(0x401000, 0xE52000, pattern, patternMask, 0);
	if (!target) {
		MessageBox(0, "Kasumi crash pattern NOT FOUND! Fix not applied!", "ME2KasumiCrashFix", MB_OK|MB_ICONWARNING);
		return 0;
	}
	DWORD originalProtection;
	VirtualProtect((void*)target, patternLength, PAGE_EXECUTE_READWRITE, &originalProtection);
	BYTE* ptr=(BYTE*)target;
	for (int i = 0; i < patternLength; i++) {
		*ptr++ = fixed[i];
	}
	VirtualProtect((void*)target, patternLength, originalProtection, NULL);
	return 0;
}

BOOL WINAPI DllMain(HINSTANCE hInst, DWORD reason, LPVOID)
{
	if (reason == DLL_PROCESS_ATTACH)
	{
		DWORD dwThreadId, dwThrdParam = 1;
		HANDLE hThread;
		hThread = CreateThread(NULL, 0, Start, &dwThrdParam, 0, &dwThreadId);
	}
	return 1;
}